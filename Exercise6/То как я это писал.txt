Опишу здесь то как я писал этот проект.

Начал с того, что создал класс Field добавил туда поля, которые я считаю нужными.
Потом сделал функции для работы с Field. Выбор случайного кол-ва бомб в диапазоне, случайного места для бомбы на поле.
Создал в классе две матрицы, одна отображается юзеру и изначально состоит из x, вторая состоит из чисел - сколько бомб вокруг данной клетки.
Написал функцию для печати матрицы юзера.
После чего начал парсить данные и проверять их на валидность.
Потом создал жизненый цикл для игры. Добавил печать, методы для установки флага и открывания ячейки.
Потом добавил рекурсивное открывание ячеек, рядом с которыми нет бомб. Но после теста оказалось, что на больших картах и при маленьком числе бомб, происходит переполнение стека. Поэтому я переписал функцию так, чтобы она запоминала какие ячейки уже посетила, и сделал это циклом, а не рекурсей.
После чего сделал функцию для победы игрока, если все бомбы помечены флажками, а ячейки открыты.
После этого распределил код по файлам, привел его к более читаемому виду.
Потом начал код для сохранения и загрузки карты. Сначала не очень понимал, как это можно сделать, ведь у нас в карте очень небольшой алфавит. Пришлось читать разную литературу и статьи по криптографии и шифрованию.
Решил, что будет неплохо, если я использую перестановоный шифр и кодирование через числа Фиббаначи. В итоге, я решил, что буду сохранять карту пользователя как есть, а для бомб сделаю следующее:
1) сделаю перестановку цифр для координат бомб.
2) Закодирую с помощью чисел Фиббаначи: начинаю считать числа с k=кол-во строк * кол-во стобцов/2 матрицы, и для каждого числа использую формулу  rs = k^2 * num^2 + 11*fib*num^2 + num^2*k*fib^3 + num^2*fib_old^3, num - число для шифрования, fib - число Фиббаначи для нынешней итерации, fib_old - для прошлой, k=кол-во строк * кол-во стобцов/2 матрицы.
Потом написал алгоритм для бота. Почитал различные источники, решил сделать следующее: бот открывает ячейки, в которых точно нет бобм, отмечает флажком те, в которых бомбы точно есть. Если бот ничего не открыл за итерацию, то открывается случайная ячейка. За основу взял идею статьи на хабре: соеденяем ячейки в группы, потом преобразовываем эти группы, чтобы получить нужную нам информацию и убрать повторяющуюся. По сути, уберем повторяющиеся группы и разъеденяемм пересекающеся.
Потом тестировал, исправлял недочеты.