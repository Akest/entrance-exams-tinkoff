Опишу здесь то как я писал этот проект.

Начал с того, что создал класс Field, добавил туда поля, которые я считаю нужными.
Потом сделал функции для работы с Field. Выбор случайного кол-ва бомб в диапазоне, случайного места для бомбы на поле.
Создал в классе две матрицы, одна отображается игроку и изначально состоит из 'x', вторая состоит из чисел - сколько бомб вокруг данной клетки.
Написал функцию для печати матрицы игрока
После чего начал парсить данные и проверять их на валидность.
Потом создал жизненный цикл для игры. Добавил печать, методы для установки флага и открывания ячейки. Имплементировал проигрыш, если игрок открыл ячейку с бомбой.
Потом добавил рекурсивное открывание ячеек, рядом с которыми нет бомб. Но после теста оказалось, что на больших картах и при маленьком числе бомб, происходит переполнение стека. Поэтому я переписал функцию так, чтобы она запоминала какие ячейки уже посетила, и сделал это циклом, а не рекурсией.
После чего сделал функцию для победы игрока, если все бомбы помечены флажками, а остальные ячейки открыты.
После этого распределил код по файлам, привел его к более читаемому виду.
Потом начал код для сохранения и загрузки карты. Сначала не очень понимал, как это можно сделать, ведь у нас в карте очень небольшой алфавит. Пришлось читать разную литературу и статьи по криптографии и шифрованию.
Подумал, что будет неплохо, если я использую перестановочный шифр и кодирование через числа Фибоначчи. В итоге я решил, что буду сохранять карту пользователя как есть, а для бомб сделаю следующее:
1) Разъединю координаты: [[x1,y1], [x2,y2]] -> [x1, y1, x2, y2].
2) Cделаю перестановку цифр для каждого числа
3) Закодирую с помощью чисел Фибоначчи: начинаю считать числа с k=кол-во строк/3 * кол-во столбцов/2 матрицы + 1, и для каждого числа использую формулу rs = k^2 * num^2 + 11*fib*num^2 + num^2*k*fib^3 + num^2*fib_old^3, num - число для шифрования, fib - число Фибоначчи для нынешней итерации, fib_old - для прошлой, k=кол-во строк * кол-во столбцов/2 матрицы.
Написал декодирование чисел в список бомб, функцию для загрузки поля. В ней проверяю валидность данных и самого файла.
Потом написал алгоритм для бота. Почитал различные источники, решил сделать следующее: бот открывает ячейки, в которых точно нет бомб, отмечает флажком те, в которых бомбы точно есть. Если бот ничего не открыл за итерацию, то открывается случайная ячейка. За основу взял идею статьи на хабре: соединяем ячейки в группы, потом преобразовываем эти группы, чтобы получить нужную нам информацию и убрать повторяющуюся. По сути, уберем повторяющиеся группы и разъединяем пересекающиеся.
Добавил, чтобы бот выигрывал, если число закрытых ячеек = числу оставшихся бомб.
Сделал, чтобы выводились команды, которые делает бот.
Потом тестировал, исправлял недочеты.